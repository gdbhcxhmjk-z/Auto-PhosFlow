# lib/g16_handler.py
import os
import re
import subprocess
from pathlib import Path


def write_gjf(folder, job_name, keywords, charge, spin, coords, old_chk=None, nproc=56, mem="512GB"):
    """
    生成 Gaussian 输入文件 (.gjf)
    """
    filename = folder / f"{job_name}.gjf"
    chk_name = f"{job_name}.chk"
    
    # 构造文件内容
    content = []
    
    # --- Link 0 Section ---
    content.append(f"%nprocshared={nproc}")
    content.append(f"%mem={mem}")
    content.append(f"%chk={chk_name}")
    
    if old_chk:
        content.append(f"%oldchk={old_chk}")
    
    # --- Route Section ---
    # 这里直接填入你 config.py 中的长字符串
    content.append(keywords)
    content.append("") # 必须空一行
    
    # --- Title Section ---
    content.append(f"Generated by Auto-PhosFlow: {job_name}")
    content.append("") # 必须空一行
    
    # --- Molecule Specification ---
    # 如果是读取几何结构 (freq calc), 不需要写坐标
    if "geom=allcheck" in keywords or "geom=check" in keywords:
        pass 
    else:
        content.append(f"{charge} {spin}")
        content.append(coords.strip()) # 确保坐标字符串前后无多余空行
        content.append("") # 必须空一行作为结束
        
    # 写入文件
    with open(filename, 'w') as f:
        f.write("\n".join(content))
        # 确保文件末尾有且仅有一个额外的空行（Gaussian 最佳实践）
        f.write("\n\n")
    
    print(f"  [Gen] Input generated: {filename}")
    return filename

def extract_geom_with_obabel(log_file, temp_dir=None):
    """
    使用 obabel 从 log 文件提取优化的几何结构。
    逻辑：
    1. 调用 obabel 将 log 转为 xyz (包含所有优化步)。
    2. 读取 xyz 文件，解析出最后一帧结构。
    """
    log_file = Path(log_file)
    if temp_dir is None:
        temp_dir = log_file.parent
    
    # 定义临时 xyz 输出路径
    xyz_out = temp_dir / f"{log_file.stem}_traj.xyz"
    
    # 1. 执行 obabel 命令
    # -i log: 输入格式
    # -o xyz: 输出格式
    cmd = f"obabel -ilog {log_file} -oxyz -O {xyz_out}"
    
    try:
        # capture_output=True 防止 obabel 的输出刷屏
        subprocess.run(cmd, shell=True, check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    except subprocess.CalledProcessError:
        raise RuntimeError(f"Obabel failed to parse {log_file}. Please check if obabel is installed/in PATH.")
    
    if not xyz_out.exists():
        raise FileNotFoundError(f"Obabel did not generate {xyz_out}")

    # 2. 从多帧 XYZ 中读取最后一帧
    # XYZ 格式:
    # Line 1: 原子数 N
    # Line 2: 注释
    # Line 3~(3+N): 坐标
    # ... 重复
    
    last_coords = []
    with open(xyz_out, 'r') as f:
        lines = f.readlines()
        
    if not lines:
        raise ValueError(f"Generated XYZ file is empty: {xyz_out}")

    try:
        # 获取原子数量 (第一行)
        num_atoms = int(lines[0].strip())
        # 计算每一帧占用的行数 (原子数 + 2行头信息)
        frame_len = num_atoms + 2
        
        # 校验文件行数
        total_lines = len(lines)
        if total_lines % frame_len != 0:
            print(f"  [Warn] XYZ file lines ({total_lines}) not divisible by frame length ({frame_len}). Taking last available block.")
            
        # 截取最后一块
        # 我们只需要坐标部分，不需要原子数和注释行 (即最后 N 行)
        start_index = total_lines - frame_len + 2 # +2 是跳过原子数和注释
        last_coords_lines = lines[start_index:]
        
        last_coords = "".join(last_coords_lines)
        
    except ValueError:
         raise ValueError(f"Could not parse atom count from first line of {xyz_out}")

    # 清理临时 trajectory 文件 (可选)
    # xyz_out.unlink() 
    
    return last_coords

def read_xyz_coords(xyz_file):
    """读取原始 XYZ 文件的简单封装"""
    with open(xyz_file, 'r') as f:
        lines = f.readlines()
    # 跳过前两行
    return "".join(lines[2:])

def check_imaginary_frequencies(log_file):
    """
    检查 Gaussian log 文件中是否存在虚频。
    返回: (has_imaginary (bool), freq_values (list))
    """
    imag_freqs = []
    if not os.path.isfile(log_file):
        return False, []

    with open(log_file, 'r', errors='ignore') as f:
        lines = f.readlines()

    for line in lines:
        if " Frequencies --" in line:
            # line 格式: " Frequencies --   -10.50    23.40    50.10"
            parts = line.split()
            # 频率数据通常从索引 2 开始
            for val in parts[2:]:
                try:
                    freq = float(val)
                    if freq < 0.0:
                        imag_freqs.append(freq)
                except ValueError:
                    pass
    
    has_imaginary = len(imag_freqs) > 0
    return has_imaginary, imag_freqs

# def check_job_elapsed_time(log_file):
#     """
#     解析 Gaussian log 末尾的 Elapsed time，返回小时数 (float)。
#     格式示例: Elapsed time:  0 days  1 hours 30 minutes 25.0 seconds.
#     """
#     if not os.path.isfile(log_file):
#         return 0.0

#     # 读取文件最后 50 行寻找时间信息
#     with open(log_file, 'rb') as f:
#         f.seek(0, 2) # Seek to end
#         file_size = f.tell()
#         seek_offset = min(file_size, 5000) # 往回读 5000 字节足够了
#         f.seek(-seek_offset, 2)
#         tail = f.read().decode('utf-8', errors='ignore')

#     # 正则匹配
#     # Elapsed time:  0 days  0 hours 45 minutes 50.2 seconds.
#     pattern = re.search(r"Elapsed time:\s+(\d+)\s+days\s+(\d+)\s+hours\s+(\d+)\s+minutes\s+([\d\.]+)\s+seconds", tail)
    
#     if pattern:
#         days = float(pattern.group(1))
#         hours = float(pattern.group(2))
#         minutes = float(pattern.group(3))
#         seconds = float(pattern.group(4))
        
#         total_hours = (days * 24.0) + hours + (minutes / 60.0) + (seconds / 3600.0)
#         return total_hours
    
#     return 0.0

def check_job_elapsed_time(log_path):
    """
    解析 Gaussian Log 末尾的 Elapsed time。
    
    逻辑特点：
    1. 倒序查找：确保读取的是最后一次任务的时间。
    2. 安全返回：失败返回 999.0，防止意外触发 < 8h 的重算逻辑。
    3. 鲁棒读取：支持 Path 对象，支持极小文件。
    
    格式示例: Elapsed time:       0 days  0 hours 18 minutes 23.5 seconds.
    返回: 执行时间 (小时, float)
    """
    # 统一转为 Path 对象，防止传入字符串报错
    log_path = Path(log_path)
    
    # 1. 文件不存在检查
    if not log_path.exists():
        # 返回极大值，确保 workflow 中 "if time < 8.0" 判断为 False
        return 999.0 

    try:
        # 2. 读取文件末尾 4KB (足够涵盖最后的时间统计)
        with open(log_path, 'rb') as f:
            try:
                f.seek(-4096, 2) # 尝试倒退 4KB
            except OSError:
                f.seek(0) # 如果文件小于 4KB，则从头读取
            
            # 解码为字符串，忽略二进制乱码
            lines = f.read().decode('utf-8', errors='ignore').splitlines()

        # 3. 倒序查找 (从最后一行往前找)
        for line in reversed(lines):
            if "Elapsed time:" in line:
                # 正则匹配
                match = re.search(r"Elapsed time:\s+(\d+)\s+days\s+(\d+)\s+hours\s+(\d+)\s+minutes\s+([\d\.]+)\s+seconds", line)
                if match:
                    days = int(match.group(1))
                    hours = int(match.group(2))
                    minutes = int(match.group(3))
                    seconds = float(match.group(4))
                    
                    total_hours = (days * 24.0) + hours + (minutes / 60.0) + (seconds / 3600.0)
                    return total_hours
        
        # 4. 如果读完了都没找到
        print(f"  [Warning] Could not find 'Elapsed time' in {log_path.name}")
        return 999.0

    except Exception as e:
        print(f"  [Error] Failed to read time from {log_path.name}: {e}")
        return 999.0